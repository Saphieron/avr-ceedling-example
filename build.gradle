/*Project properties  */
def ceedlingRootFolder = 'project_' + project.name
def targetDevice = 'atmega2560' // Target device name according to avr-gcc

/*Internal settings. Please DO NOT change unless you know what you are doing*/
def ceedlingProjectYaml = ceedlingRootFolder + '/' + 'project.yml'
def supportLibraryOutputFolder = ceedlingRootFolder + '/test/support'
def supportSourceFolder = 'support_files'
def configurationsFolder = 'configuration_files'

/*
Callable/usable tasks
*/


//Construction/init task
task initCeedling{
	doLast{
		exec{
			workingDir '.'
			commandLine 'ceedling', 'new', ceedlingRootFolder	
		}
	}
}
configure(initCeedling){
	group = 'Ceedling'
	description = 'creates initial folder structure for a ceedling project'
}

//Local tests
task testLocalAll(dependsOn: 'copyProjectLocalYaml'){
	doLast{
		exec{
			ignoreExitValue = true
			workingDir ceedlingRootFolder
			commandLine 'ceedling', 'clobber', 'test:all'
		}
	}
}
configure(testLocalAll){
	group = 'Ceedling'
	description = 'run all tests on the local machine'
}

task testLocalSingle(dependsOn: 'copyProjectLocalYaml'){
	def testFile = project.hasProperty("testfile") ? project.testfile : ''
	doLast{
		exec{
			workingDir ceedlingRootFolder
			commandLine 'ceedling', 'clobber', 'test:' + testfile
		}
	}
}
configure(testLocalSingle){
	group = 'Ceedling'
	description = 'run a subset or single test on the target. Allows for regex. To use: gradle testTargetSingle -P<testFileRegex>'
}

//Target tests
task testTargetAll(dependsOn: 'copyProjectTargetYaml'){
	doLast{
		exec{
			ignoreExitValue = true
			workingDir ceedlingRootFolder
			commandLine 'ceedling', 'clobber', 'test:all'
		}
	}
}
configure(testTargetAll){
	group = 'Ceedling'
	description = 'run all tests on the target'
}

task testTargetSingle(dependsOn: 'copyProjectTargetYaml'){
	def testFile = project.hasProperty("testfile") ? project.testfile : ''
	doLast{
		exec{
			workingDir ceedlingRootFolder
			commandLine 'ceedling', 'clobber', 'test:' + testfile
		}
	}
}
configure(testTargetSingle){
	group = 'Ceedling'
	description = 'run a subset or single test on the target. Allows for regex. To use: gradle testTargetSingle -P<testFileRegex>'
}


//Internal tasks

task copyProjectLocalYaml(type: Copy){
		from configurationsFolder + '/local.yml'
		into ceedlingRootFolder + '/'
		rename ('local.yml', 'project.yml')
}

task copyProjectTargetYaml(dependsOn: 'copyBuiltSupportLib'){
	doLast{
		copy{
			from(configurationsFolder + ''){
				include 'target.yml'
			}
			into ceedlingRootFolder + '/'
			rename ('target.yml', 'project.yml')
		}
	}
}


task copyBuiltSupportLib(dependsOn: 'UartSupportStaticLibrary'){
	doLast{
		copy{
			from('build/libs/uartSupport/static/'){
				include 'libUartSupport.a'
				
			}
			from(supportSourceFolder + '/'){
				include 'uart_output.h'
				include 'unity_config.h'
			}
			into supportLibraryOutputFolder + '/'			
		}
	}
}

/*C compilation tasks for building support uart library for same platform as target*/
apply plugin: "c"

model {
	platforms {
		avr {
			architecture "avr"
		}
	}

	toolChains {
		gcc(Gcc) {
			target("avr") {
				cCompiler.executable = "avr-gcc"
				cCompiler.withArguments {args ->
					args << "-mmcu=" + targetDevice
				}
				cCompiler.withArguments {args ->
					args << "-DF_CPU=16000000UL"
				}
				linker.executable = "avr-gcc"
				linker.withArguments {args ->
					args << "-mmcu=" + targetDevice << "-mrelax"
				}
				staticLibArchiver.executable = "avr-ar"
				staticLibArchiver.withArguments{ args ->
					println "----> avr-ar args: " + args
				}
			}
		}
	}

	buildTypes {
		release
	}

	binaries {
		all {
			cCompiler.args "-Wall"
			cCompiler.args "-g2", "-gstabs"
			cCompiler.args "-fpack-struct", "-fshort-enums", "-ffunction-sections", "-fdata-sections"
			cCompiler.args "-funsigned-char", "-funsigned-bitfields"
			cCompiler.args "-std=c99"
			if (buildType == buildTypes.release) {
				cCompiler.args "-O2"
			}
			linker.args "-Wl,--gc-sections"
		}
	}

	components{
		UartSupport(NativeLibrarySpec){	
			targetPlatform "avr"
			sources {
				c {
					source {
						srcDir supportSourceFolder
						include "uart_output.c"
					}
				}
			}

			binaries.withType(SharedLibraryBinarySpec) {
				buildable = false
			}
		}
	}


	tasks {
		UartSupportStaticLibrary{
			dependsOn clean
		}
	}
}
